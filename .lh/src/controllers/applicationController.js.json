{
    "sourceFile": "src/controllers/applicationController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1760415413617,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760415598139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,42 +1,84 @@\n import Application from '../models/Application.js';\n import Event from '../models/Event.js';\n \n-// ... existing exports (apply, listApplicants) stay as-is\n+// --- USER APPLY FOR EVENT ---\n+export async function apply(req, res) {\n+  try {\n+    const { eventId } = req.body;\n+    const existing = await Application.findOne({ event: eventId, user: req.user._id });\n+    if (existing) return res.status(400).json({ message: 'Already applied to this event' });\n \n+    const app = await Application.create({\n+      event: eventId,\n+      user: req.user._id,\n+      status: 'applied',\n+    });\n+    res.status(201).json(app);\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Server error while applying' });\n+  }\n+}\n+\n+// --- ADMIN: SEE APPLICANTS FOR SPECIFIC EVENT ---\n+export async function listApplicants(req, res) {\n+  try {\n+    const apps = await Application.find({ event: req.params.id })\n+      .populate('user', 'name email')\n+      .populate('event', 'title startAt');\n+    res.json(apps);\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Error fetching applicants' });\n+  }\n+}\n+\n+// --- ADMIN: SEE ALL APPLICATIONS ---\n export async function listAllApplications(req, res) {\n-  const { eventId, status, page = 1, limit = 25 } = req.query;\n-  const where = {};\n-  if (eventId) where.event = eventId;\n-  if (status) where.status = status;\n+  try {\n+    const { eventId, status, page = 1, limit = 25 } = req.query;\n+    const where = {};\n+    if (eventId) where.event = eventId;\n+    if (status) where.status = status;\n \n-  const skip = (Number(page) - 1) * Number(limit);\n+    const skip = (Number(page) - 1) * Number(limit);\n+    const q = Application.find(where)\n+      .sort({ createdAt: -1 })\n+      .skip(skip)\n+      .limit(Number(limit))\n+      .populate('user', 'name email')\n+      .populate('event', 'title startAt');\n \n-  // populate user & event for admin view\n-  const q = Application.find(where)\n-    .sort({ createdAt: -1 })\n-    .skip(skip)\n-    .limit(Number(limit))\n-    .populate('user', 'name email')\n-    .populate('event', 'title startAt');\n-\n-  const [items, total] = await Promise.all([q, Application.countDocuments(where)]);\n-  res.json({ items, total, page: Number(page), pages: Math.ceil(total / Number(limit)) });\n+    const [items, total] = await Promise.all([q, Application.countDocuments(where)]);\n+    res.json({ items, total, page: Number(page), pages: Math.ceil(total / Number(limit)) });\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Error listing applications' });\n+  }\n }\n \n+// --- ADMIN: STATS ---\n export async function applicationStats(req, res) {\n-  // count applications per event\n-  const grouped = await Application.aggregate([\n-    { $group: { _id: '$event', count: { $sum: 1 } } },\n-    { $sort: { count: -1 } }\n-  ]);\n-  const ids = grouped.map(g => g._id);\n-  const events = await Event.find({ _id: { $in: ids } }, { title: 1, startAt: 1 });\n-  const eventMap = Object.fromEntries(events.map(e => [e._id.toString(), e]));\n-  const stats = grouped.map(g => ({\n-    eventId: g._id,\n-    title: eventMap[g._id.toString()]?.title || 'Unknown Event',\n-    startAt: eventMap[g._id.toString()]?.startAt || null,\n-    applications: g.count\n-  }));\n-  res.json({ stats });\n+  try {\n+    const grouped = await Application.aggregate([\n+      { $group: { _id: '$event', count: { $sum: 1 } } },\n+      { $sort: { count: -1 } }\n+    ]);\n+\n+    const ids = grouped.map(g => g._id);\n+    const events = await Event.find({ _id: { $in: ids } }, { title: 1, startAt: 1 });\n+    const eventMap = Object.fromEntries(events.map(e => [e._id.toString(), e]));\n+\n+    const stats = grouped.map(g => ({\n+      eventId: g._id,\n+      title: eventMap[g._id.toString()]?.title || 'Unknown',\n+      startAt: eventMap[g._id.toString()]?.startAt || null,\n+      applications: g.count\n+    }));\n+\n+    res.json({ stats });\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Error fetching stats' });\n+  }\n }\n"
                },
                {
                    "date": 1760510738605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import Application from '../models/Application.js';\n import Event from '../models/Event.js';\n+import { v2 as cloudinary } from 'cloudinary';\n \n // --- USER APPLY FOR EVENT ---\n export async function apply(req, res) {\n   try {\n"
                },
                {
                    "date": 1760510764924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,4 +82,54 @@\n     console.error(err);\n     res.status(500).json({ message: 'Error fetching stats' });\n   }\n }\n+\n+\n+\n+// ✅ Update event (with optional media re-upload)\n+export async function updateEvent(req, res) {\n+  try {\n+    const { id } = req.params;\n+    const body = req.body;\n+\n+    const event = await Event.findById(id);\n+    if (!event) return res.status(404).json({ message: 'Event not found' });\n+\n+    // handle new file uploads (if multipart form)\n+    if (req.files?.length) {\n+      const uploads = await Promise.all(\n+        req.files.map(f =>\n+          new Promise((resolve, reject) => {\n+            const stream = cloudinary.uploader.upload_stream(\n+              { resource_type: 'auto' },\n+              (err, result) => (err ? reject(err) : resolve(result))\n+            );\n+            stream.end(f.buffer);\n+          })\n+        )\n+      );\n+      body.media = uploads.map(u => ({\n+        url: u.secure_url,\n+        kind: u.resource_type === 'video' ? 'video' : 'image',\n+      }));\n+    }\n+\n+    const updated = await Event.findByIdAndUpdate(id, body, { new: true });\n+    res.json(updated);\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Server error' });\n+  }\n+}\n+\n+// ✅ Delete event\n+export async function deleteEvent(req, res) {\n+  try {\n+    const { id } = req.params;\n+    const e = await Event.findByIdAndDelete(id);\n+    if (!e) return res.status(404).json({ message: 'Event not found' });\n+    res.json({ message: 'Event deleted successfully' });\n+  } catch (err) {\n+    res.status(500).json({ message: 'Server error' });\n+  }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1760510828602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,51 +85,4 @@\n }\n \n \n \n-// ✅ Update event (with optional media re-upload)\n-export async function updateEvent(req, res) {\n-  try {\n-    const { id } = req.params;\n-    const body = req.body;\n-\n-    const event = await Event.findById(id);\n-    if (!event) return res.status(404).json({ message: 'Event not found' });\n-\n-    // handle new file uploads (if multipart form)\n-    if (req.files?.length) {\n-      const uploads = await Promise.all(\n-        req.files.map(f =>\n-          new Promise((resolve, reject) => {\n-            const stream = cloudinary.uploader.upload_stream(\n-              { resource_type: 'auto' },\n-              (err, result) => (err ? reject(err) : resolve(result))\n-            );\n-            stream.end(f.buffer);\n-          })\n-        )\n-      );\n-      body.media = uploads.map(u => ({\n-        url: u.secure_url,\n-        kind: u.resource_type === 'video' ? 'video' : 'image',\n-      }));\n-    }\n-\n-    const updated = await Event.findByIdAndUpdate(id, body, { new: true });\n-    res.json(updated);\n-  } catch (err) {\n-    console.error(err);\n-    res.status(500).json({ message: 'Server error' });\n-  }\n-}\n-\n-// ✅ Delete event\n-export async function deleteEvent(req, res) {\n-  try {\n-    const { id } = req.params;\n-    const e = await Event.findByIdAndDelete(id);\n-    if (!e) return res.status(404).json({ message: 'Event not found' });\n-    res.json({ message: 'Event deleted successfully' });\n-  } catch (err) {\n-    res.status(500).json({ message: 'Server error' });\n-  }\n-}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1760510833911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,87 @@\n+import Application from '../models/Application.js';\n+import Event from '../models/Event.js';\n+\n+// --- USER APPLY FOR EVENT ---\n+export async function apply(req, res) {\n+  try {\n+    const { eventId } = req.body;\n+    const existing = await Application.findOne({ event: eventId, user: req.user._id });\n+    if (existing) return res.status(400).json({ message: 'Already applied to this event' });\n+\n+    const app = await Application.create({\n+      event: eventId,\n+      user: req.user._id,\n+      status: 'applied',\n+    });\n+    res.status(201).json(app);\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Server error while applying' });\n+  }\n+}\n+\n+// --- ADMIN: SEE APPLICANTS FOR SPECIFIC EVENT ---\n+export async function listApplicants(req, res) {\n+  try {\n+    const apps = await Application.find({ event: req.params.id })\n+      .populate('user', 'name email')\n+      .populate('event', 'title startAt');\n+    res.json(apps);\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Error fetching applicants' });\n+  }\n+}\n+\n+// --- ADMIN: SEE ALL APPLICATIONS ---\n+export async function listAllApplications(req, res) {\n+  try {\n+    const { eventId, status, page = 1, limit = 25 } = req.query;\n+    const where = {};\n+    if (eventId) where.event = eventId;\n+    if (status) where.status = status;\n+\n+    const skip = (Number(page) - 1) * Number(limit);\n+    const q = Application.find(where)\n+      .sort({ createdAt: -1 })\n+      .skip(skip)\n+      .limit(Number(limit))\n+      .populate('user', 'name email')\n+      .populate('event', 'title startAt');\n+\n+    const [items, total] = await Promise.all([q, Application.countDocuments(where)]);\n+    res.json({ items, total, page: Number(page), pages: Math.ceil(total / Number(limit)) });\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Error listing applications' });\n+  }\n+}\n+\n+// --- ADMIN: STATS ---\n+export async function applicationStats(req, res) {\n+  try {\n+    const grouped = await Application.aggregate([\n+      { $group: { _id: '$event', count: { $sum: 1 } } },\n+      { $sort: { count: -1 } }\n+    ]);\n+\n+    const ids = grouped.map(g => g._id);\n+    const events = await Event.find({ _id: { $in: ids } }, { title: 1, startAt: 1 });\n+    const eventMap = Object.fromEntries(events.map(e => [e._id.toString(), e]));\n+\n+    const stats = grouped.map(g => ({\n+      eventId: g._id,\n+      title: eventMap[g._id.toString()]?.title || 'Unknown',\n+      startAt: eventMap[g._id.toString()]?.startAt || null,\n+      applications: g.count\n+    }));\n+\n+    res.json({ stats });\n+  } catch (err) {\n+    console.error(err);\n+    res.status(500).json({ message: 'Error fetching stats' });\n+  }\n+}\n+\n+\n+\n"
                },
                {
                    "date": 1760553044023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n import Application from '../models/Application.js';\n import Event from '../models/Event.js';\n \n+import { sendEventAppliedEmail } from '../utils/sendMail.js';\n // --- USER APPLY FOR EVENT ---\n export async function apply(req, res) {\n   try {\n     const { eventId } = req.body;\n@@ -84,92 +85,4 @@\n }\n \n \n \n-import Application from '../models/Application.js';\n-import Event from '../models/Event.js';\n-import { v2 as cloudinary } from 'cloudinary';\n-\n-// --- USER APPLY FOR EVENT ---\n-export async function apply(req, res) {\n-  try {\n-    const { eventId } = req.body;\n-    const existing = await Application.findOne({ event: eventId, user: req.user._id });\n-    if (existing) return res.status(400).json({ message: 'Already applied to this event' });\n-\n-    const app = await Application.create({\n-      event: eventId,\n-      user: req.user._id,\n-      status: 'applied',\n-    });\n-    res.status(201).json(app);\n-  } catch (err) {\n-    console.error(err);\n-    res.status(500).json({ message: 'Server error while applying' });\n-  }\n-}\n-\n-// --- ADMIN: SEE APPLICANTS FOR SPECIFIC EVENT ---\n-export async function listApplicants(req, res) {\n-  try {\n-    const apps = await Application.find({ event: req.params.id })\n-      .populate('user', 'name email')\n-      .populate('event', 'title startAt');\n-    res.json(apps);\n-  } catch (err) {\n-    console.error(err);\n-    res.status(500).json({ message: 'Error fetching applicants' });\n-  }\n-}\n-\n-// --- ADMIN: SEE ALL APPLICATIONS ---\n-export async function listAllApplications(req, res) {\n-  try {\n-    const { eventId, status, page = 1, limit = 25 } = req.query;\n-    const where = {};\n-    if (eventId) where.event = eventId;\n-    if (status) where.status = status;\n-\n-    const skip = (Number(page) - 1) * Number(limit);\n-    const q = Application.find(where)\n-      .sort({ createdAt: -1 })\n-      .skip(skip)\n-      .limit(Number(limit))\n-      .populate('user', 'name email')\n-      .populate('event', 'title startAt');\n-\n-    const [items, total] = await Promise.all([q, Application.countDocuments(where)]);\n-    res.json({ items, total, page: Number(page), pages: Math.ceil(total / Number(limit)) });\n-  } catch (err) {\n-    console.error(err);\n-    res.status(500).json({ message: 'Error listing applications' });\n-  }\n-}\n-\n-// --- ADMIN: STATS ---\n-export async function applicationStats(req, res) {\n-  try {\n-    const grouped = await Application.aggregate([\n-      { $group: { _id: '$event', count: { $sum: 1 } } },\n-      { $sort: { count: -1 } }\n-    ]);\n-\n-    const ids = grouped.map(g => g._id);\n-    const events = await Event.find({ _id: { $in: ids } }, { title: 1, startAt: 1 });\n-    const eventMap = Object.fromEntries(events.map(e => [e._id.toString(), e]));\n-\n-    const stats = grouped.map(g => ({\n-      eventId: g._id,\n-      title: eventMap[g._id.toString()]?.title || 'Unknown',\n-      startAt: eventMap[g._id.toString()]?.startAt || null,\n-      applications: g.count\n-    }));\n-\n-    res.json({ stats });\n-  } catch (err) {\n-    console.error(err);\n-    res.status(500).json({ message: 'Error fetching stats' });\n-  }\n-}\n-\n-\n-\n"
                },
                {
                    "date": 1760553087225,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,10 @@\n import Application from '../models/Application.js';\n import Event from '../models/Event.js';\n \n import { sendEventAppliedEmail } from '../utils/sendMail.js';\n+\n+\n // --- USER APPLY FOR EVENT ---\n export async function apply(req, res) {\n   try {\n     const { eventId } = req.body;\n@@ -18,8 +20,19 @@\n   } catch (err) {\n     console.error(err);\n     res.status(500).json({ message: 'Server error while applying' });\n   }\n+\n+  try {\n+    await sendEventAppliedEmail({\n+      to: req.user.email,           // or user.email\n+      userName: req.user.name,      // optional\n+      event,\n+    });\n+  } catch (e) {\n+    console.warn('[mail] failed to send apply email', e.message);\n+  }\n+  res.status(201).json(appDoc);\n }\n \n // --- ADMIN: SEE APPLICANTS FOR SPECIFIC EVENT ---\n export async function listApplicants(req, res) {\n"
                },
                {
                    "date": 1760596614399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,10 @@\n     });\n   } catch (e) {\n     console.warn('[mail] failed to send apply email', e.message);\n   }\n-  res.status(201).json(appDoc);\n+  res.status(201).json(app);\n+\n }\n \n // --- ADMIN: SEE APPLICANTS FOR SPECIFIC EVENT ---\n export async function listApplicants(req, res) {\n"
                },
                {
                    "date": 1760596727707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,17 +23,16 @@\n   }\n \n   try {\n     await sendEventAppliedEmail({\n-      to: req.user.email,           // or user.email\n-      userName: req.user.name,      // optional\n+      to: req.user.email,\n+      userName: req.user.name,\n       event,\n     });\n   } catch (e) {\n     console.warn('[mail] failed to send apply email', e.message);\n   }\n   res.status(201).json(app);\n-\n }\n \n // --- ADMIN: SEE APPLICANTS FOR SPECIFIC EVENT ---\n export async function listApplicants(req, res) {\n"
                },
                {
                    "date": 1760597500668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,83 +1,120 @@\n+// server/src/controllers/applicationController.js\n import Application from '../models/Application.js';\n import Event from '../models/Event.js';\n-\n import { sendEventAppliedEmail } from '../utils/sendMail.js';\n \n-\n-// --- USER APPLY FOR EVENT ---\n+/**\n+ * USER: Apply for an event\n+ * POST /api/v1/applications\n+ * body: { eventId, note? }\n+ */\n export async function apply(req, res) {\n   try {\n-    const { eventId } = req.body;\n-    const existing = await Application.findOne({ event: eventId, user: req.user._id });\n-    if (existing) return res.status(400).json({ message: 'Already applied to this event' });\n+    const { eventId, note } = req.body;\n+    const userId = req.user?.id || req.user?._id;\n \n+    if (!eventId) {\n+      return res.status(400).json({ message: 'eventId is required' });\n+    }\n+\n+    // Ensure event exists\n+    const event = await Event.findById(eventId);\n+    if (!event) {\n+      return res.status(404).json({ message: 'Event not found' });\n+    }\n+\n+    // Prevent duplicate application by same user\n+    const existing = await Application.findOne({ event: eventId, user: userId });\n+    if (existing) {\n+      return res.status(400).json({ message: 'You already applied for this event' });\n+    }\n+\n+    // Create application\n     const app = await Application.create({\n       event: eventId,\n-      user: req.user._id,\n-      status: 'applied',\n+      user: userId,\n+      note: note || '',\n+      status: 'pending', // or 'applied' if that’s your schema\n     });\n-    res.status(201).json(app);\n-  } catch (err) {\n-    console.error(err);\n-    res.status(500).json({ message: 'Server error while applying' });\n-  }\n \n-  try {\n-    await sendEventAppliedEmail({\n+    // Fire-and-forget email (don’t block response if it fails)\n+    sendEventAppliedEmail({\n       to: req.user.email,\n       userName: req.user.name,\n       event,\n-    });\n-  } catch (e) {\n-    console.warn('[mail] failed to send apply email', e.message);\n+    }).catch(err => console.warn('[mail] failed to send apply email:', err.message));\n+\n+    return res.status(201).json(app);\n+  } catch (err) {\n+    console.error(err);\n+    return res.status(500).json({ message: 'Server error while applying' });\n   }\n-  res.status(201).json(app);\n }\n \n-// --- ADMIN: SEE APPLICANTS FOR SPECIFIC EVENT ---\n+/**\n+ * ADMIN: List applicants for a specific event\n+ * GET /api/v1/applications/event/:id\n+ */\n export async function listApplicants(req, res) {\n   try {\n     const apps = await Application.find({ event: req.params.id })\n       .populate('user', 'name email')\n       .populate('event', 'title startAt');\n-    res.json(apps);\n+    return res.json(apps);\n   } catch (err) {\n     console.error(err);\n-    res.status(500).json({ message: 'Error fetching applicants' });\n+    return res.status(500).json({ message: 'Error fetching applicants' });\n   }\n }\n \n-// --- ADMIN: SEE ALL APPLICATIONS ---\n+/**\n+ * ADMIN: List all applications (with filters + pagination)\n+ * GET /api/v1/applications?eventId=&status=&page=&limit=\n+ */\n export async function listAllApplications(req, res) {\n   try {\n     const { eventId, status, page = 1, limit = 25 } = req.query;\n+\n     const where = {};\n     if (eventId) where.event = eventId;\n     if (status) where.status = status;\n \n     const skip = (Number(page) - 1) * Number(limit);\n-    const q = Application.find(where)\n+\n+    const query = Application.find(where)\n       .sort({ createdAt: -1 })\n       .skip(skip)\n       .limit(Number(limit))\n       .populate('user', 'name email')\n       .populate('event', 'title startAt');\n \n-    const [items, total] = await Promise.all([q, Application.countDocuments(where)]);\n-    res.json({ items, total, page: Number(page), pages: Math.ceil(total / Number(limit)) });\n+    const [items, total] = await Promise.all([\n+      query,\n+      Application.countDocuments(where),\n+    ]);\n+\n+    return res.json({\n+      items,\n+      total,\n+      page: Number(page),\n+      pages: Math.ceil(total / Number(limit)),\n+    });\n   } catch (err) {\n     console.error(err);\n-    res.status(500).json({ message: 'Error listing applications' });\n+    return res.status(500).json({ message: 'Error listing applications' });\n   }\n }\n \n-// --- ADMIN: STATS ---\n+/**\n+ * ADMIN: Applications per event stats\n+ * GET /api/v1/applications/stats\n+ */\n export async function applicationStats(req, res) {\n   try {\n     const grouped = await Application.aggregate([\n       { $group: { _id: '$event', count: { $sum: 1 } } },\n-      { $sort: { count: -1 } }\n+      { $sort: { count: -1 } },\n     ]);\n \n     const ids = grouped.map(g => g._id);\n     const events = await Event.find({ _id: { $in: ids } }, { title: 1, startAt: 1 });\n@@ -86,16 +123,13 @@\n     const stats = grouped.map(g => ({\n       eventId: g._id,\n       title: eventMap[g._id.toString()]?.title || 'Unknown',\n       startAt: eventMap[g._id.toString()]?.startAt || null,\n-      applications: g.count\n+      applications: g.count,\n     }));\n \n-    res.json({ stats });\n+    return res.json({ stats });\n   } catch (err) {\n     console.error(err);\n-    res.status(500).json({ message: 'Error fetching stats' });\n+    return res.status(500).json({ message: 'Error fetching stats' });\n   }\n }\n-\n-\n-\n"
                },
                {
                    "date": 1760599953723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,22 +28,30 @@\n     if (existing) {\n       return res.status(400).json({ message: 'You already applied for this event' });\n     }\n \n-    // Create application\n+    // IMPORTANT: use a status allowed by your schema (likely 'applied')\n     const app = await Application.create({\n       event: eventId,\n       user: userId,\n       note: note || '',\n-      status: 'pending', // or 'applied' if that’s your schema\n+      status: 'applied',\n     });\n \n-    // Fire-and-forget email (don’t block response if it fails)\n-    sendEventAppliedEmail({\n-      to: req.user.email,\n-      userName: req.user.name,\n-      event,\n-    }).catch(err => console.warn('[mail] failed to send apply email:', err.message));\n+    // Try to send confirmation email; don't block response\n+    const toEmail =\n+      req.user?.email || process.env.SMTP_USER || process.env.EMAIL_USER;\n+    if (toEmail) {\n+      sendEventAppliedEmail({\n+        to: toEmail,\n+        userName: req.user?.name || 'there',\n+        event,\n+      }).catch(err =>\n+        console.warn('[mail] failed to send apply email:', err.message)\n+      );\n+    } else {\n+      console.warn('[mail] skipped sending email: no recipient available');\n+    }\n \n     return res.status(201).json(app);\n   } catch (err) {\n     console.error(err);\n"
                },
                {
                    "date": 1760644540429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,47 +15,43 @@\n \n     if (!eventId) {\n       return res.status(400).json({ message: 'eventId is required' });\n     }\n+    if (!mongoose.isValidObjectId(eventId)) {\n+      return res.status(400).json({ message: 'Invalid eventId' });\n+    }\n \n-    // Ensure event exists\n     const event = await Event.findById(eventId);\n     if (!event) {\n       return res.status(404).json({ message: 'Event not found' });\n     }\n \n-    // Prevent duplicate application by same user\n     const existing = await Application.findOne({ event: eventId, user: userId });\n     if (existing) {\n-      return res.status(400).json({ message: 'You already applied for this event' });\n+      return res.status(409).json({ message: 'You already applied for this event' });\n     }\n \n-    // IMPORTANT: use a status allowed by your schema (likely 'applied')\n     const app = await Application.create({\n       event: eventId,\n       user: userId,\n       note: note || '',\n       status: 'applied',\n     });\n \n-    // Try to send confirmation email; don't block response\n-    const toEmail =\n-      req.user?.email || process.env.SMTP_USER || process.env.EMAIL_USER;\n+    const toEmail = req.user?.email || process.env.SMTP_USER || process.env.EMAIL_USER;\n     if (toEmail) {\n       sendEventAppliedEmail({\n         to: toEmail,\n         userName: req.user?.name || 'there',\n         event,\n-      }).catch(err =>\n-        console.warn('[mail] failed to send apply email:', err.message)\n-      );\n+      }).catch(e => console.warn('[mail] failed to send apply email:', e.message));\n     } else {\n-      console.warn('[mail] skipped sending email: no recipient available');\n+      console.warn('[mail] skipped: no recipient');\n     }\n \n     return res.status(201).json(app);\n   } catch (err) {\n-    console.error(err);\n+    console.error('[apply] error:', err);\n     return res.status(500).json({ message: 'Server error while applying' });\n   }\n }\n \n"
                },
                {
                    "date": 1760644599988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n // server/src/controllers/applicationController.js\n+\n import Application from '../models/Application.js';\n import Event from '../models/Event.js';\n import { sendEventAppliedEmail } from '../utils/sendMail.js';\n \n"
                },
                {
                    "date": 1761281564787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n // server/src/controllers/applicationController.js\n-\n+import mongoose from 'mongoose';\n import Application from '../models/Application.js';\n import Event from '../models/Event.js';\n import { sendEventAppliedEmail } from '../utils/sendMail.js';\n \n@@ -109,12 +109,9 @@\n     return res.status(500).json({ message: 'Error listing applications' });\n   }\n }\n \n-/**\n- * ADMIN: Applications per event stats\n- * GET /api/v1/applications/stats\n- */\n+\n export async function applicationStats(req, res) {\n   try {\n     const grouped = await Application.aggregate([\n       { $group: { _id: '$event', count: { $sum: 1 } } },\n"
                }
            ],
            "date": 1760415413616,
            "name": "Commit-0",
            "content": "import Application from '../models/Application.js';\nimport Event from '../models/Event.js';\n\n// ... existing exports (apply, listApplicants) stay as-is\n\nexport async function listAllApplications(req, res) {\n  const { eventId, status, page = 1, limit = 25 } = req.query;\n  const where = {};\n  if (eventId) where.event = eventId;\n  if (status) where.status = status;\n\n  const skip = (Number(page) - 1) * Number(limit);\n\n  // populate user & event for admin view\n  const q = Application.find(where)\n    .sort({ createdAt: -1 })\n    .skip(skip)\n    .limit(Number(limit))\n    .populate('user', 'name email')\n    .populate('event', 'title startAt');\n\n  const [items, total] = await Promise.all([q, Application.countDocuments(where)]);\n  res.json({ items, total, page: Number(page), pages: Math.ceil(total / Number(limit)) });\n}\n\nexport async function applicationStats(req, res) {\n  // count applications per event\n  const grouped = await Application.aggregate([\n    { $group: { _id: '$event', count: { $sum: 1 } } },\n    { $sort: { count: -1 } }\n  ]);\n  const ids = grouped.map(g => g._id);\n  const events = await Event.find({ _id: { $in: ids } }, { title: 1, startAt: 1 });\n  const eventMap = Object.fromEntries(events.map(e => [e._id.toString(), e]));\n  const stats = grouped.map(g => ({\n    eventId: g._id,\n    title: eventMap[g._id.toString()]?.title || 'Unknown Event',\n    startAt: eventMap[g._id.toString()]?.startAt || null,\n    applications: g.count\n  }));\n  res.json({ stats });\n}\n"
        }
    ]
}